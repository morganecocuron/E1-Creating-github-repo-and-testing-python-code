from sys import maxsize 
from itertools import permutations
import matplotlib.pyplot as plt
import time

# Function to measure time taken by the TSP algorithm
def measure_time_tsp(graph, s, V):
    start_time = time.time()

    # store all vertex apart from source vertex 
    vertex = [] 
    for i in range(V): 
        if i != s: 
            vertex.append(i) 

    # store minimum weight Hamiltonian Cycle 
    min_path = maxsize 
    next_permutation=permutations(vertex)
    for i in next_permutation:

        # store current Path weight(cost) 
        current_pathweight = 0

        # compute current path weight 
        k = s 
        for j in i: 
            current_pathweight += graph[k][j] 
            k = j 
        current_pathweight += graph[k][s] 

        # update minimum 
        min_path = min(min_path, current_pathweight) 

    end_time = time.time()
    return end_time - start_time

# Driver Code 
if __name__ == "__main__": 

    # List to store the number of cities and corresponding time
    num_cities = []
    time_taken = []

    for V in range(1, 11):  # Test for 4 to 10 cities
        # matrix representation of graph 
        graph = [[0 for _ in range(V)] for _ in range(V)]
        for i in range(V):
            for j in range(V):
                if i != j:
                    graph[i][j] = i + j  # Example weights, you may use actual weights for your problem
        num_cities.append(V)
        time_taken.append(measure_time_tsp(graph, 0, V))

    # Time taken as a function of the number of cities
    plt.plot(num_cities, time_taken, marker='o')
    plt.xlabel('Number of Cities')
    plt.ylabel('Time Taken (s)')
    plt.title('Time Taken for TSP as a Function of Number of Cities')
    plt.grid(True)
    plt.show()
